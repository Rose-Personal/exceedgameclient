#!/usr/bin/env python3
"""
Generate docs/effects/index.md from the directory structure.
Scans all effect directories and extracts descriptions from each effect file.

Usage: python tools/generate_effects_index.py
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Tuple

def extract_effect_info(file_path: Path) -> Tuple[str, str, str]:
    """
    Extract title, category, and description from an effect markdown file.

    Returns:
        (title, category, description)
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Extract title (first line starting with #)
        title_match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
        title = title_match.group(1).strip() if title_match else file_path.stem

        # Extract category
        category_match = re.search(r'\*\*Category\*\*:\s*(.+)$', content, re.MULTILINE)
        category = category_match.group(1).strip() if category_match else "Unknown"

        # Extract description
        desc_match = re.search(r'\*\*Description\*\*:\s*(.+)$', content, re.MULTILINE)
        description = desc_match.group(1).strip() if desc_match else "No description available"

        return title, category, description

    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return file_path.stem, "Unknown", "Error reading file"

def scan_effects_directory(effects_dir: Path) -> Dict[str, List[Dict[str, str]]]:
    """
    Scan the effects directory and organize effects by category.

    Returns:
        Dictionary with category names as keys and lists of effect info as values
    """
    effects_by_category = {}
    for category_dir in effects_dir.iterdir():
        if not category_dir.is_dir():
            continue

        category_name = category_dir.name
        effects_list = []

        for effect_file in category_dir.iterdir():
            if effect_file.suffix == '.md':
                title, category, description = extract_effect_info(effect_file)

                effects_list.append({
                    'title': title,
                    'filename': effect_file.name,
                    'category': category,
                    'description': description,
                    'relative_path': f"{category_name}/{effect_file.name}"
                })

        if effects_list:
            # Sort effects alphabetically by title
            effects_list.sort(key=lambda x: x['title'].lower())
            effects_by_category[category_name] = effects_list

    return effects_by_category

def generate_index_content(effects_by_category: Dict[str, List[Dict[str, str]]]) -> str:
    """
    Generate the complete index.md content.
    """
    content = []

    # Header
    content.append("# Strike Effects Index")
    content.append("")
    content.append("Complete alphabetical index of all strike effects with quick links.")
    content.append("")
    content.append("*This file is automatically generated by `tools/generate_effects_index.py`. Do not edit manually.*")
    content.append("")

    # Calculate totals
    total_effects = sum(len(effects) for effects in effects_by_category.values())
    total_categories = len(effects_by_category)

    content.append(f"**Total Effects**: {total_effects} across {total_categories} categories")
    content.append("")

    # Table of contents
    content.append("## Quick Navigation")
    content.append("")
    for category_name in sorted(effects_by_category.keys()):
        effect_count = len(effects_by_category[category_name])
        content.append(f"- [{category_name.title()} Effects](#-{category_name.lower()}-effects-{effect_count}) ({effect_count} effects)")
    content.append("- [Alphabetical Index](#alphabetical-index)")
    content.append("")

    # Category sections
    content.append("## By Category")
    content.append("")

    # Category mappings for better titles
    category_titles = {
        'movement': 'Movement',
        'stats': 'Stat Modification',
        'cards': 'Card Management',
        'attack': 'Attack Modification',
        'choice': 'Choice and Selection',
        'boost': 'Boost',
        'gauge': 'Gauge and Force',
        'buddy': 'Buddy and Placement',
        'seal': 'Seal and Transform',
        'protection': 'Protection and Passive',
        'life': 'Life and Damage',
        'special': 'Special Mechanics',
        'utility': 'Utility'
    }

    for category_name in sorted(effects_by_category.keys()):
        effects = effects_by_category[category_name]
        category_title = category_titles.get(category_name, category_name.title())

        content.append(f"### ðŸ”¸ {category_title} Effects ({len(effects)})")
        content.append("")

        for effect in effects:
            content.append(f"- [{effect['title']}]({effect['relative_path']}) - {effect['description']}")

        content.append("")

    # Alphabetical index
    content.append("## Alphabetical Index")
    content.append("")

    # Collect all effects and sort alphabetically
    all_effects = []
    for category_effects in effects_by_category.values():
        all_effects.extend(category_effects)

    all_effects.sort(key=lambda x: x['title'].lower())

    # Group by first letter
    current_letter = ''
    for effect in all_effects:
        first_letter = effect['title'][0].upper()
        if first_letter != current_letter:
            if current_letter:  # Add spacing between letter groups
                content.append("")
            content.append(f"### {first_letter}")
            content.append("")
            current_letter = first_letter

        content.append(f"- [{effect['title']}]({effect['relative_path']}) ({effect['category']}) - {effect['description']}")

    content.append("")

    # Footer
    content.append("---")
    content.append("")
    content.append("## About This Index")
    content.append("")
    content.append("This index is automatically generated from the effect documentation files.")
    content.append("Each effect includes:")
    content.append("- **Category** - Functional grouping")
    content.append("- **Description** - What the effect does")
    content.append("- **Parameters** - Required and optional parameters with types")
    content.append("- **Supported Timings** - When this effect can be used")
    content.append("- **Examples** - Real usage from card definitions")
    content.append("- **Implementation Notes** - Edge cases and behavior details")
    content.append("- **Related Effects** - Cross-references to similar effects")
    content.append("")
    content.append("To regenerate this index: `python tools/generate_effects_index.py`")
    content.append("")

    return '\n'.join(content)

def main():
    """Main function to generate the index."""
    # Get paths relative to script location
    script_dir = Path(__file__).parent
    project_dir = script_dir.parent
    effects_dir = project_dir / 'docs' / 'effects'
    index_file = effects_dir / 'index.md'

    if not effects_dir.exists():
        print(f"Error: Effects directory not found at {effects_dir}")
        return 1

    print(f"Scanning effects directory: {effects_dir}")

    # Scan for effects
    effects_by_category = scan_effects_directory(effects_dir)

    if not effects_by_category:
        print("No effect categories found!")
        return 1

    # Generate content
    print("Generating index content...")
    content = generate_index_content(effects_by_category)

    # Write to file
    try:
        with open(index_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Successfully generated {index_file}")

        # Print summary
        total_effects = sum(len(effects) for effects in effects_by_category.values())
        print(f"\nSummary:")
        print(f"- {len(effects_by_category)} categories")
        print(f"- {total_effects} total effects")

        for category, effects in sorted(effects_by_category.items()):
            print(f"  - {category}: {len(effects)} effects")

    except Exception as e:
        print(f"Error writing index file: {e}")
        return 1

    return 0


if __name__ == '__main__':
    exit(main())